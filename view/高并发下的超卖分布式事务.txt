超卖问题

减库存步骤: 1)查询余量num=10  2)判断是否充足  3)减库存下单成功.
update tab set num=num-1 where num =10.
并发访问情况下,因为多线程操作,查询和修改是会开的,会出现超卖问题.

悲观锁:认为线程安全问题一定发生,每次查询都所表,select ... for update
乐观锁:认为线程安全问题不会发生,查询时不锁表,在修改数据时做校验,逻辑锁
update tab set num=num-1 where num =10

刚才乐观锁写频率过高,导致数据库压力过大,很有可能就崩溃了.


高并发情况,乐观锁也解决不了问题.数据库压力过大.

采用同步写变异步写

不直接操作数据库,而是把数据库库存读到内存中(redis单线程安全,并发能力10w+),在内存中完成减库存操作,再把生成订单和减库存的任务通过MQ交给数据库操作.
redis操作,要用到批操作或者说redis事务.以及watch num,将乐观锁从硬盘操作转移到内存操作.

方案一: 用简单的key和value结构,利用redis事务监控该字段(利用redis的乐观锁操作,watch)

方案二: 用list结构(队列)初始化向队列中填等于储存量的数据,每次请求到达调用lpop取,根据返回的结果是否为null判断是否失败,解决了数据库的并发写问题(同步写变异步写,MQ)

补充: 可以在nginx处也可以操作redis(perl脚本对redis操作),将请求在nginx处操作判断,开始拦截,后端系统更安全.

但引入新问题,并发的请求会从数据库转移到nginx判断了,用户会不断刷新页面.
静态化页面. 将页面静态化,保存在nginx, 那么所有的请求不再到达tomcat,而是直接由nginx处理.后端就安全了.

静态化页面虽然大部分是静态的,但还有部分如js等静态资源请求访问,应该租cdn服务器存放静态资源

补充: 
nginx压力过大怎么办? nginx集群,通过keeplived实现nginx的主从,页面缓存,静态资源缓存. 使用cdn服务器,把静态资源全部由cdn处理

减库存操作中,下单是订单系统完成,减库存是由后台的库存功能完成,不属于一个系统,就出现了分布式事务问题,如何解决?

三种方案: 1)分段式提交,atomiks,比较老的技术非常麻烦
		2)利用MQ实现事务最终一致.
		3)TXC(阿里的分布式事务中间件GTC)即try-confirm-cancel
